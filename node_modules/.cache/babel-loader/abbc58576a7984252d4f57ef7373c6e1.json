{"ast":null,"code":"\"use strict\";\n\nvar _classCallCheck = require(\"/Users/centricgateway/Documents/projects/appraisal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"/Users/centricgateway/Documents/projects/appraisal/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar path = require(\"path\");\n\nvar process = require(\"process\");\n\nvar childProcess = require(\"child_process\");\n\nvar semver = require(\"semver\");\n\nvar chalk_1 = require(\"chalk\");\n\nvar micromatch = require(\"micromatch\");\n\nvar os = require(\"os\");\n\nvar CancellationToken_1 = require(\"./CancellationToken\");\n\nvar NormalizedMessage_1 = require(\"./NormalizedMessage\");\n\nvar defaultFormatter_1 = require(\"./formatter/defaultFormatter\");\n\nvar codeframeFormatter_1 = require(\"./formatter/codeframeFormatter\");\n\nvar FsHelper_1 = require(\"./FsHelper\");\n\nvar hooks_1 = require(\"./hooks\");\n\nvar checkerPluginName = 'fork-ts-checker-webpack-plugin';\n/**\n * ForkTsCheckerWebpackPlugin\n * Runs typescript type checker and linter (tslint) on separate process.\n * This speed-ups build a lot.\n *\n * Options description in README.md\n */\n\nvar ForkTsCheckerWebpackPlugin =\n/*#__PURE__*/\nfunction () {\n  function ForkTsCheckerWebpackPlugin(options) {\n    var _this = this;\n\n    _classCallCheck(this, ForkTsCheckerWebpackPlugin);\n\n    this.startAt = 0;\n\n    this.computeContextPath = function (filePath) {\n      return path.isAbsolute(filePath) ? filePath : path.resolve(_this.compiler.options.context, filePath);\n    };\n\n    options = options || {};\n    this.options = Object.assign({}, options);\n    this.tsconfig = options.tsconfig || './tsconfig.json';\n    this.compilerOptions = typeof options.compilerOptions === 'object' ? options.compilerOptions : {};\n    this.tslint = options.tslint ? options.tslint === true ? './tslint.json' : options.tslint : undefined;\n    this.tslintAutoFix = options.tslintAutoFix || false;\n    this.watch = typeof options.watch === 'string' ? [options.watch] : options.watch || [];\n    this.ignoreDiagnostics = options.ignoreDiagnostics || [];\n    this.ignoreLints = options.ignoreLints || [];\n    this.reportFiles = options.reportFiles || [];\n    this.logger = options.logger || console;\n    this.silent = options.silent === true; // default false\n\n    this.async = options.async !== false; // default true\n\n    this.checkSyntacticErrors = options.checkSyntacticErrors === true; // default false\n\n    this.workersNumber = options.workers || ForkTsCheckerWebpackPlugin.ONE_CPU;\n    this.memoryLimit = options.memoryLimit || ForkTsCheckerWebpackPlugin.DEFAULT_MEMORY_LIMIT;\n    this.useColors = options.colors !== false; // default true\n\n    this.colors = new chalk_1.default.constructor({\n      enabled: this.useColors\n    });\n    this.formatter = options.formatter && typeof options.formatter === 'function' ? options.formatter : ForkTsCheckerWebpackPlugin.createFormatter(options.formatter || 'default', options.formatterOptions || {});\n    this.useTypescriptIncrementalApi = options.useTypescriptIncrementalApi || false;\n    this.tsconfigPath = undefined;\n    this.tslintPath = undefined;\n    this.watchPaths = [];\n    this.compiler = undefined;\n    this.started = undefined;\n    this.elapsed = undefined;\n    this.cancellationToken = undefined;\n    this.isWatching = false;\n    this.checkDone = false;\n    this.compilationDone = false;\n    this.diagnostics = [];\n    this.lints = [];\n    this.emitCallback = this.createNoopEmitCallback();\n    this.doneCallback = this.createDoneCallback();\n    this.typescriptPath = options.typescript || require.resolve('typescript');\n\n    try {\n      this.typescript = require(this.typescriptPath);\n      this.typescriptVersion = this.typescript.version;\n    } catch (_ignored) {\n      throw new Error('When you use this plugin you must install `typescript`.');\n    }\n\n    try {\n      this.tslintVersion = this.tslint ? // tslint:disable-next-line:no-implicit-dependencies\n      require('tslint').Linter.VERSION : undefined;\n    } catch (_ignored) {\n      throw new Error('When you use `tslint` option, make sure to install `tslint`.');\n    }\n\n    this.validateVersions();\n    this.vue = options.vue === true; // default false\n\n    this.measureTime = options.measureCompilationTime === true;\n\n    if (this.measureTime) {\n      // Node 8+ only\n      this.performance = require('perf_hooks').performance;\n    }\n  }\n\n  _createClass(ForkTsCheckerWebpackPlugin, [{\n    key: \"validateVersions\",\n    value: function validateVersions() {\n      if (semver.lt(this.typescriptVersion, '2.1.0')) {\n        throw new Error(\"Cannot use current typescript version of \".concat(this.typescriptVersion, \", the minimum required version is 2.1.0\"));\n      } else if (this.tslintVersion && semver.lt(this.tslintVersion, '4.0.0')) {\n        throw new Error(\"Cannot use current tslint version of \".concat(this.tslintVersion, \", the minimum required version is 4.0.0\"));\n      }\n    }\n  }, {\n    key: \"apply\",\n    value: function apply(compiler) {\n      this.compiler = compiler;\n      this.tsconfigPath = this.computeContextPath(this.tsconfig);\n      this.tslintPath = this.tslint ? this.computeContextPath(this.tslint) : undefined;\n      this.watchPaths = this.watch.map(this.computeContextPath); // validate config\n\n      var tsconfigOk = FsHelper_1.FsHelper.existsSync(this.tsconfigPath);\n      var tslintOk = !this.tslintPath || FsHelper_1.FsHelper.existsSync(this.tslintPath);\n\n      if (this.useTypescriptIncrementalApi && this.workersNumber !== 1) {\n        throw new Error('Using typescript incremental compilation API ' + 'is currently only allowed with a single worker.');\n      } // validate logger\n\n\n      if (this.logger) {\n        if (!this.logger.error || !this.logger.warn || !this.logger.info) {\n          throw new Error(\"Invalid logger object - doesn't provide `error`, `warn` or `info` method.\");\n        }\n      }\n\n      if (tsconfigOk && tslintOk) {\n        this.pluginStart();\n        this.pluginStop();\n        this.pluginCompile();\n        this.pluginEmit();\n        this.pluginDone();\n      } else {\n        if (!tsconfigOk) {\n          throw new Error('Cannot find \"' + this.tsconfigPath + '\" file. Please check webpack and ForkTsCheckerWebpackPlugin configuration. \\n' + 'Possible errors: \\n' + '  - wrong `context` directory in webpack configuration' + ' (if `tsconfig` is not set or is a relative path in fork plugin configuration)\\n' + '  - wrong `tsconfig` path in fork plugin configuration' + ' (should be a relative or absolute path)');\n        }\n\n        if (!tslintOk) {\n          throw new Error('Cannot find \"' + this.tslintPath + '\" file. Please check webpack and ForkTsCheckerWebpackPlugin configuration. \\n' + 'Possible errors: \\n' + '  - wrong `context` directory in webpack configuration' + ' (if `tslint` is not set or is a relative path in fork plugin configuration)\\n' + '  - wrong `tslint` path in fork plugin configuration' + ' (should be a relative or absolute path)\\n' + '  - `tslint` path is not set to false in fork plugin configuration' + ' (if you want to disable tslint support)');\n        }\n      }\n    }\n  }, {\n    key: \"pluginStart\",\n    value: function pluginStart() {\n      var _this2 = this;\n\n      var run = function run(_compiler, callback) {\n        _this2.isWatching = false;\n        callback();\n      };\n\n      var watchRun = function watchRun(_compiler, callback) {\n        _this2.isWatching = true;\n        callback();\n      };\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        this.compiler.hooks.run.tapAsync(checkerPluginName, run);\n        this.compiler.hooks.watchRun.tapAsync(checkerPluginName, watchRun);\n      } else {\n        // webpack 2 / 3\n        this.compiler.plugin('run', run);\n        this.compiler.plugin('watch-run', watchRun);\n      }\n    }\n  }, {\n    key: \"pluginStop\",\n    value: function pluginStop() {\n      var _this3 = this;\n\n      var watchClose = function watchClose() {\n        _this3.killService();\n      };\n\n      var done = function done(_stats) {\n        if (!_this3.isWatching) {\n          _this3.killService();\n        }\n      };\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        this.compiler.hooks.watchClose.tap(checkerPluginName, watchClose);\n        this.compiler.hooks.done.tap(checkerPluginName, done);\n      } else {\n        // webpack 2 / 3\n        this.compiler.plugin('watch-close', watchClose);\n        this.compiler.plugin('done', done);\n      }\n\n      process.on('exit', function () {\n        _this3.killService();\n      });\n    }\n  }, {\n    key: \"pluginCompile\",\n    value: function pluginCompile() {\n      var _this4 = this;\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n        this.compiler.hooks.compile.tap(checkerPluginName, function () {\n          _this4.compilationDone = false;\n          forkTsCheckerHooks.serviceBeforeStart.callAsync(function () {\n            if (_this4.cancellationToken) {\n              // request cancellation if there is not finished job\n              _this4.cancellationToken.requestCancellation();\n\n              forkTsCheckerHooks.cancel.call(_this4.cancellationToken);\n            }\n\n            _this4.checkDone = false;\n            _this4.started = process.hrtime(); // create new token for current job\n\n            _this4.cancellationToken = new CancellationToken_1.CancellationToken(_this4.typescript);\n\n            if (!_this4.service || !_this4.service.connected) {\n              _this4.spawnService();\n            }\n\n            try {\n              if (_this4.measureTime) {\n                _this4.startAt = _this4.performance.now();\n              }\n\n              _this4.service.send(_this4.cancellationToken);\n            } catch (error) {\n              if (!_this4.silent && _this4.logger) {\n                _this4.logger.error(_this4.colors.red('Cannot start checker service: ' + (error ? error.toString() : 'Unknown error')));\n              }\n\n              forkTsCheckerHooks.serviceStartError.call(error);\n            }\n          });\n        });\n      } else {\n        // webpack 2 / 3\n        this.compiler.plugin('compile', function () {\n          _this4.compilationDone = false;\n\n          _this4.compiler.applyPluginsAsync(hooks_1.legacyHookMap.serviceBeforeStart, function () {\n            if (_this4.cancellationToken) {\n              // request cancellation if there is not finished job\n              _this4.cancellationToken.requestCancellation();\n\n              _this4.compiler.applyPlugins(hooks_1.legacyHookMap.cancel, _this4.cancellationToken);\n            }\n\n            _this4.checkDone = false;\n            _this4.started = process.hrtime(); // create new token for current job\n\n            _this4.cancellationToken = new CancellationToken_1.CancellationToken(_this4.typescript, undefined, undefined);\n\n            if (!_this4.service || !_this4.service.connected) {\n              _this4.spawnService();\n            }\n\n            try {\n              _this4.service.send(_this4.cancellationToken);\n            } catch (error) {\n              if (!_this4.silent && _this4.logger) {\n                _this4.logger.error(_this4.colors.red('Cannot start checker service: ' + (error ? error.toString() : 'Unknown error')));\n              }\n\n              _this4.compiler.applyPlugins(hooks_1.legacyHookMap.serviceStartError, error);\n            }\n          });\n        });\n      }\n    }\n  }, {\n    key: \"pluginEmit\",\n    value: function pluginEmit() {\n      var _this5 = this;\n\n      var emit = function emit(compilation, callback) {\n        if (_this5.isWatching && _this5.async) {\n          callback();\n          return;\n        }\n\n        _this5.emitCallback = _this5.createEmitCallback(compilation, callback);\n\n        if (_this5.checkDone) {\n          _this5.emitCallback();\n        }\n\n        _this5.compilationDone = true;\n      };\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        this.compiler.hooks.emit.tapAsync(checkerPluginName, emit);\n      } else {\n        // webpack 2 / 3\n        this.compiler.plugin('emit', emit);\n      }\n    }\n  }, {\n    key: \"pluginDone\",\n    value: function pluginDone() {\n      var _this6 = this;\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n        this.compiler.hooks.done.tap(checkerPluginName, function (_stats) {\n          if (!_this6.isWatching || !_this6.async) {\n            return;\n          }\n\n          if (_this6.checkDone) {\n            _this6.doneCallback();\n          } else {\n            if (_this6.compiler) {\n              forkTsCheckerHooks.waiting.call(_this6.tslint !== false);\n            }\n\n            if (!_this6.silent && _this6.logger) {\n              _this6.logger.info(_this6.tslint ? 'Type checking and linting in progress...' : 'Type checking in progress...');\n            }\n          }\n\n          _this6.compilationDone = true;\n        });\n      } else {\n        // webpack 2 / 3\n        this.compiler.plugin('done', function () {\n          if (!_this6.isWatching || !_this6.async) {\n            return;\n          }\n\n          if (_this6.checkDone) {\n            _this6.doneCallback();\n          } else {\n            if (_this6.compiler) {\n              _this6.compiler.applyPlugins(hooks_1.legacyHookMap.waiting, _this6.tslint !== false);\n            }\n\n            if (!_this6.silent && _this6.logger) {\n              _this6.logger.info(_this6.tslint ? 'Type checking and linting in progress...' : 'Type checking in progress...');\n            }\n          }\n\n          _this6.compilationDone = true;\n        });\n      }\n    }\n  }, {\n    key: \"spawnService\",\n    value: function spawnService() {\n      var _this7 = this;\n\n      this.service = childProcess.fork(path.resolve(__dirname, this.workersNumber > 1 ? './cluster.js' : './service.js'), [], {\n        execArgv: this.workersNumber > 1 ? [] : ['--max-old-space-size=' + this.memoryLimit],\n        env: Object.assign({}, process.env, {\n          TYPESCRIPT_PATH: this.typescriptPath,\n          TSCONFIG: this.tsconfigPath,\n          COMPILER_OPTIONS: JSON.stringify(this.compilerOptions),\n          TSLINT: this.tslintPath || '',\n          TSLINTAUTOFIX: this.tslintAutoFix,\n          WATCH: this.isWatching ? this.watchPaths.join('|') : '',\n          WORK_DIVISION: Math.max(1, this.workersNumber),\n          MEMORY_LIMIT: this.memoryLimit,\n          CHECK_SYNTACTIC_ERRORS: this.checkSyntacticErrors,\n          USE_INCREMENTAL_API: this.options.useTypescriptIncrementalApi === true,\n          VUE: this.vue\n        }),\n        stdio: ['inherit', 'inherit', 'inherit', 'ipc']\n      });\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n        forkTsCheckerHooks.serviceStart.call(this.tsconfigPath, this.tslintPath, this.watchPaths, this.workersNumber, this.memoryLimit);\n      } else {\n        // webpack 2 / 3\n        this.compiler.applyPlugins(hooks_1.legacyHookMap.serviceStart, this.tsconfigPath, this.tslintPath, this.watchPaths, this.workersNumber, this.memoryLimit);\n      }\n\n      if (!this.silent && this.logger) {\n        this.logger.info('Starting type checking' + (this.tslint ? ' and linting' : '') + ' service...');\n        this.logger.info('Using ' + this.colors.bold(this.workersNumber === 1 ? '1 worker' : this.workersNumber + ' workers') + ' with ' + this.colors.bold(this.memoryLimit + 'MB') + ' memory limit');\n\n        if (this.watchPaths.length && this.isWatching) {\n          this.logger.info('Watching:' + (this.watchPaths.length > 1 ? '\\n' : ' ') + this.watchPaths.map(function (wpath) {\n            return _this7.colors.grey(wpath);\n          }).join('\\n'));\n        }\n      }\n\n      this.service.on('message', function (message) {\n        return _this7.handleServiceMessage(message);\n      });\n      this.service.on('exit', function (code, signal) {\n        return _this7.handleServiceExit(code, signal);\n      });\n    }\n  }, {\n    key: \"killService\",\n    value: function killService() {\n      if (!this.service) {\n        return;\n      }\n\n      try {\n        if (this.cancellationToken) {\n          this.cancellationToken.cleanupCancellation();\n        }\n\n        this.service.kill();\n        this.service = undefined;\n      } catch (e) {\n        if (this.logger && !this.silent) {\n          this.logger.error(e);\n        }\n      }\n    }\n  }, {\n    key: \"handleServiceMessage\",\n    value: function handleServiceMessage(message) {\n      var _this8 = this;\n\n      if (this.measureTime) {\n        var delta = this.performance.now() - this.startAt;\n        this.logger.info(\"compilation took: \".concat(delta, \" ms.\"));\n      }\n\n      if (this.cancellationToken) {\n        this.cancellationToken.cleanupCancellation(); // job is done - nothing to cancel\n\n        this.cancellationToken = undefined;\n      }\n\n      this.checkDone = true;\n      this.elapsed = process.hrtime(this.started);\n      this.diagnostics = message.diagnostics.map(NormalizedMessage_1.NormalizedMessage.createFromJSON);\n      this.lints = message.lints.map(NormalizedMessage_1.NormalizedMessage.createFromJSON);\n\n      if (this.ignoreDiagnostics.length) {\n        this.diagnostics = this.diagnostics.filter(function (diagnostic) {\n          return !_this8.ignoreDiagnostics.includes(parseInt(diagnostic.code, 10));\n        });\n      }\n\n      if (this.ignoreLints.length) {\n        this.lints = this.lints.filter(function (lint) {\n          return !_this8.ignoreLints.includes(lint.code);\n        });\n      }\n\n      if (this.reportFiles.length) {\n        var reportFilesPredicate = function reportFilesPredicate(diagnostic) {\n          if (diagnostic.file) {\n            var relativeFileName = path.relative(_this8.compiler.options.context, diagnostic.file);\n            var matchResult = micromatch([relativeFileName], _this8.reportFiles);\n\n            if (matchResult.length === 0) {\n              return false;\n            }\n          }\n\n          return true;\n        };\n\n        this.diagnostics = this.diagnostics.filter(reportFilesPredicate);\n        this.lints = this.lints.filter(reportFilesPredicate);\n      }\n\n      if ('hooks' in this.compiler) {\n        // webpack 4+\n        var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n        forkTsCheckerHooks.receive.call(this.diagnostics, this.lints);\n      } else {\n        // webpack 2 / 3\n        this.compiler.applyPlugins(hooks_1.legacyHookMap.receive, this.diagnostics, this.lints);\n      }\n\n      if (this.compilationDone) {\n        this.isWatching && this.async ? this.doneCallback() : this.emitCallback();\n      }\n    }\n  }, {\n    key: \"handleServiceExit\",\n    value: function handleServiceExit(_code, signal) {\n      if (signal !== 'SIGABRT') {\n        return;\n      } // probably out of memory :/\n\n\n      if (this.compiler) {\n        if ('hooks' in this.compiler) {\n          // webpack 4+\n          var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n          forkTsCheckerHooks.serviceOutOfMemory.call();\n        } else {\n          // webpack 2 / 3\n          this.compiler.applyPlugins(hooks_1.legacyHookMap.serviceOutOfMemory);\n        }\n      }\n\n      if (!this.silent && this.logger) {\n        this.logger.error(this.colors.red('Type checking and linting aborted - probably out of memory. ' + 'Check `memoryLimit` option in ForkTsCheckerWebpackPlugin configuration.'));\n      }\n    }\n  }, {\n    key: \"createEmitCallback\",\n    value: function createEmitCallback(compilation, callback) {\n      return function emitCallback() {\n        var _this9 = this;\n\n        if (!this.elapsed) {\n          throw new Error('Execution order error');\n        }\n\n        var elapsed = Math.round(this.elapsed[0] * 1e9 + this.elapsed[1]);\n\n        if ('hooks' in this.compiler) {\n          // webpack 4+\n          var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n          forkTsCheckerHooks.emit.call(this.diagnostics, this.lints, elapsed);\n        } else {\n          // webpack 2 / 3\n          this.compiler.applyPlugins(hooks_1.legacyHookMap.emit, this.diagnostics, this.lints, elapsed);\n        }\n\n        this.diagnostics.concat(this.lints).forEach(function (message) {\n          // webpack message format\n          var formatted = {\n            rawMessage: message.severity.toUpperCase() + ' ' + message.getFormattedCode() + ': ' + message.content,\n            message: _this9.formatter(message, _this9.useColors),\n            location: {\n              line: message.line,\n              character: message.character\n            },\n            file: message.file\n          };\n\n          if (message.isWarningSeverity()) {\n            compilation.warnings.push(formatted);\n          } else {\n            compilation.errors.push(formatted);\n          }\n        });\n        callback();\n      };\n    }\n  }, {\n    key: \"createNoopEmitCallback\",\n    value: function createNoopEmitCallback() {\n      // tslint:disable-next-line:no-empty\n      return function noopEmitCallback() {};\n    }\n  }, {\n    key: \"createDoneCallback\",\n    value: function createDoneCallback() {\n      return function doneCallback() {\n        var _this10 = this;\n\n        if (!this.elapsed) {\n          throw new Error('Execution order error');\n        }\n\n        var elapsed = Math.round(this.elapsed[0] * 1e9 + this.elapsed[1]);\n\n        if (this.compiler) {\n          if ('hooks' in this.compiler) {\n            // webpack 4+\n            var forkTsCheckerHooks = ForkTsCheckerWebpackPlugin.getCompilerHooks(this.compiler);\n            forkTsCheckerHooks.done.call(this.diagnostics, this.lints, elapsed);\n          } else {\n            // webpack 2 / 3\n            this.compiler.applyPlugins(hooks_1.legacyHookMap.done, this.diagnostics, this.lints, elapsed);\n          }\n        }\n\n        if (!this.silent && this.logger) {\n          if (this.diagnostics.length || this.lints.length) {\n            (this.lints || []).concat(this.diagnostics).forEach(function (message) {\n              var formattedMessage = _this10.formatter(message, _this10.useColors);\n\n              message.isWarningSeverity() ? _this10.logger.warn(formattedMessage) : _this10.logger.error(formattedMessage);\n            });\n          }\n\n          if (!this.diagnostics.length) {\n            this.logger.info(this.colors.green('No type errors found'));\n          }\n\n          if (this.tslint && !this.lints.length) {\n            this.logger.info(this.colors.green('No lint errors found'));\n          }\n\n          this.logger.info('Version: typescript ' + this.colors.bold(this.typescriptVersion) + (this.tslint ? ', tslint ' + this.colors.bold(this.tslintVersion) : ''));\n          this.logger.info('Time: ' + this.colors.bold(Math.round(elapsed / 1e6).toString()) + 'ms');\n        }\n      };\n    }\n  }], [{\n    key: \"getCompilerHooks\",\n    value: function getCompilerHooks(compiler) {\n      return hooks_1.getForkTsCheckerWebpackPluginHooks(compiler);\n    }\n  }, {\n    key: \"createFormatter\",\n    value: function createFormatter(type, options) {\n      switch (type) {\n        case 'default':\n          return defaultFormatter_1.createDefaultFormatter();\n\n        case 'codeframe':\n          return codeframeFormatter_1.createCodeframeFormatter(options);\n\n        default:\n          throw new Error('Unknown \"' + type + '\" formatter. Available are: default, codeframe.');\n      }\n    }\n  }]);\n\n  return ForkTsCheckerWebpackPlugin;\n}();\n\nForkTsCheckerWebpackPlugin.DEFAULT_MEMORY_LIMIT = 2048;\nForkTsCheckerWebpackPlugin.ONE_CPU = 1;\nForkTsCheckerWebpackPlugin.ALL_CPUS = os.cpus && os.cpus() ? os.cpus().length : 1;\nForkTsCheckerWebpackPlugin.ONE_CPU_FREE = Math.max(1, ForkTsCheckerWebpackPlugin.ALL_CPUS - 1);\nForkTsCheckerWebpackPlugin.TWO_CPUS_FREE = Math.max(1, ForkTsCheckerWebpackPlugin.ALL_CPUS - 2);\nmodule.exports = ForkTsCheckerWebpackPlugin;","map":null,"metadata":{},"sourceType":"script"}